package nl.saxion;

import robocode.TeamRobot;

public class CornerDefender extends TeamRobot {
// hier variabelen
    private int moveDirection = 1; // 1 = forward, -1 = backwards

    private static final double PERCENTAGEBATTLEFIELD = 0.20;
    private static final int DISTANCEFROMWALL = 50;

    public void run(){
    // hier startPosition()
        while (true) {
        // hier algemene run methode
        }
       }
        
        // hier methodes toevoegen
        
     /**
     * @author William
     */
    public void goStartPosition() {
        double dynamicWidth;
        turnLeft(getHeading() - 180);

        setAhead(getY() - DISTANCEFROMWALL);
        while (getDistanceRemaining() > 0) {
            execute();
        }

        turnRight(90);

        dynamicWidth = (getBattleFieldWidth() * PERCENTAGEBATTLEFIELD);

        setAhead(getX() - getWidth() - dynamicWidth);
        while (getDistanceRemaining() > 0) {
            execute();
        }
        
     /**
     * @Author Olivier
     */
    private void goCornerLeft(){
        if(getHeading()>270){
            double turnDegrees = -270+getHeading();
            turnLeft(turnDegrees);
            //320 - x = 270
            //- x = 270 - 320
            //x = -270 + 320
        }else if(getHeading()<270){
            double turnDegrees = (270.0-getHeading());
            turnRight(turnDegrees);
            //220 + x = 270
            //x = 270 - 220
        }

        ahead(getX()-DISTANCEFROMWALL);
        turnLeft(90);

        double percentage = getBattleFieldHeight()*PERCENTAGEBATTLEFIELD;
        double distance = getY() - percentage;
        // 300 + x = 680
        // x = 680-300
        ahead(distance);
        
     }
     
    /**
     * @author Yaolee
     */
    public void doStrafing() {
        setTurnRight(Math.toDegrees(Math.atan(getBattleFieldHeight() / getBattleFieldWidth())));

        // strafe by changing direction every 10 ticks
        if (getTime() % 10 == 0) {
            moveDirection *= -1;
            setAhead(150 * moveDirection);
        }
    }

    /**
     * @author Yaolee
     */
    public void reverseDirection() {
        if (moveDirection == 1) {
            setBack(10000);
        } else {
            setAhead(10000);
        }
    }

    /**
     * @author Yaolee
     */
    public void onHitWall(HitWallEvent e) {
        reverseDirection();
    }

    /**
     * @author Yaolee
     */
    public void onScannedRobot(ScannedRobotEvent e){
        // Calculate exact location of the robot
        double absoluteBearing = getHeading() + e.getBearing();
        double bearingFromGun = normalRelativeAngleDegrees(absoluteBearing - getGunHeading());
        double bearingFromRadar = normalRelativeAngleDegrees(absoluteBearing - getRadarHeading());

        // If it's close enough, fire!
        if (Math.abs(bearingFromGun) <= 3) {
            setTurnGunRight(bearingFromGun);
            setTurnRadarRight(bearingFromRadar); // keep the radar focused on the enemy

            if (getGunHeat() == 0 && getEnergy() > .2) {
                // never fires a bullet bigger than 3, just flooring the value to be safe
                setFire(Math.min(400 / e.getDistance(), 3));
            }
        } else {
            setTurnGunRight(bearingFromGun);
            setTurnRadarRight(bearingFromRadar);
        }

        if (bearingFromGun == 0) {
            scan();
        }
    }
 }
