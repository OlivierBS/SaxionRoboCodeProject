package nl.saxion;

import robocode.HitWallEvent;
import robocode.ScannedRobotEvent;
import robocode.TeamRobot;

import static robocode.util.Utils.normalRelativeAngleDegrees;

public class CornerDefender extends TeamRobot {
    private int moveDirection = 1; // 1 = forward, -1 = backwards
    private static final double PERCENTAGEBATTLEFIELD = 0.20;
    private static final int DISTANCEFROMWALL = 50;

    public void run() {
        setDefenderColor();
        // right CornerDefender
        goCornerRight();
        setTurnRight(45);
        // left CornerDefender
//        goCornerLeft();
//        setTurnLeft(45);
        while (true) {
            doStrafing();
            setTurnRadarRight(360); // scan until you find your first enemy
            execute();
        }
    }
    
    /**
     * @author William
     */
    public void goCornerRight() {
        double dynamicWidth;
        turnLeft(getHeading() - 180);

        setAhead(getY() - DISTANCEFROMWALL);
        while (getDistanceRemaining() > 0) {
            execute();
        }

        turnRight(90);

        dynamicWidth = (getBattleFieldWidth() * PERCENTAGEBATTLEFIELD);

        setAhead(getX() - getWidth() - dynamicWidth);
        while (getDistanceRemaining() > 0) {
            execute();
        }
    }

    /**
     * @Author Olivier
     */
    private void goCornerLeft() {
        if (getHeading() > 270) {
            double turnDegrees = -270 + getHeading();
            turnLeft(turnDegrees);

        } else if (getHeading() < 270) {
            double turnDegrees = (270.0 - getHeading());
            turnRight(turnDegrees);

        }

        ahead(getX() - DISTANCEFROMWALL);
        turnLeft(90);

        double percentage = getBattleFieldHeight() * PERCENTAGEBATTLEFIELD;
        double distance = getY() - percentage;

        ahead(distance);

    }

    /**
     * @author Yaolee
     */
    public void doStrafing() {
        // strafe by changing direction every 25 ticks
        if (getTime() % 25 == 0) {
            setMaxVelocity(3);
            moveDirection *= -1;
            setAhead(200 * moveDirection);
        }
    }

    /**
     * @author Yaolee
     */
    public void reverseDirection() {
        if (moveDirection == 1) {
            setBack(10000);
        } else {
            setAhead(10000);
        }
    }

    /**
     * @author Yaolee
     */
    public void onHitWall(HitWallEvent e) {
        reverseDirection();
    }

    /**
     * @author Yaolee
     */
    public void onScannedRobot(ScannedRobotEvent e) {
        // Calculate exact location of the robot
        double absoluteBearing = getHeading() + e.getBearing();
        double bearingFromGun = normalRelativeAngleDegrees(absoluteBearing - getGunHeading());
        double bearingFromRadar = normalRelativeAngleDegrees(absoluteBearing - getRadarHeading());

        // If it's close enough, fire!
        if (Math.abs(bearingFromGun) <= 3) {
            setTurnGunRight(bearingFromGun);
            setTurnRadarRight(bearingFromRadar); // keep the radar focused on the enemy

            if (getGunHeat() == 0 && getEnergy() > .2) {
                // never fires a bullet bigger than 3, just flooring the value to be safe
                setFire(Math.min(400 / e.getDistance(), 3));
            }
        } else {
            setTurnGunRight(bearingFromGun);
            setTurnRadarRight(bearingFromRadar);
        }

        if (bearingFromGun == 0) {
            scan();
        }
    }
    
    /**
     * @author William
     */
    private void setDefenderColor() {
        setBodyColor(new Color(0, 0, 0));
        setGunColor(new Color(255, 0, 0));
        setRadarColor(new Color(0, 0, 0));
        setBulletColor(new Color(255, 0, 0));
        setScanColor(new Color(0, 0, 0));
    }
}
